注意到能影响当前点的操作是当前点到根的路径上的点以及根这些点
相关联的所有操作,其他都无关.
所以我们只需要在进入u子树的时候将u相关的操作全部作用进去, 离
开u子树的时候将u相关的操作全部取消,相当于时刻维护着根到当前节
点的所有修改.
dfs序转换之后就变成了, 有若干次区间的覆盖,删除操作,跟u相关的所
有操作会插入一次,删除一次, 每批量插入完一次后会查询全局覆盖的
长度的并。
这个可以用线段树解决, 线段树的处理技巧类似于求矩形面积并(可以
自行学习)
简单说来就是在区间合并的时候,如果发现当前区间的懒惰标记大于0,
那么当前区间被覆盖的总长就可以直接记为区间长度, 否则就等于左右
儿子之和
很多人可能会奇怪, 懒惰标记不下传, 不会导致标记不真实么? 求并的
时候比较特殊的一点是只要能判断标记大于0就可以了, 不需要知道具
体是多少, 而且如果当前区间被上方的大区间覆盖了,回溯的时候一定
会碰到上面的完全覆盖的大区间,将上面的信息传递下来也没啥用.
注意这个线段树下面的sum值可能是假的(因为很多点的标记不下传
了),但是sum[1]一定是真的